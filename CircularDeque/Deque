#include <iostream>
#include <stdexcept>

template <typename T>
class CircularDeque {
private:
    T* buffer;
    int capacity;
    int size;
    int frontIndex;
    int rearIndex;

    void resize() {
        int newCapacity = capacity == 0 ? 1 : capacity * 2;
        T* newBuffer = new T[newCapacity];
        for (int i = 0; i < size; ++i)
            newBuffer[i] = (*this)[i];
        delete[] buffer;
        buffer = newBuffer;
        capacity = newCapacity;
        frontIndex = 0;
        rearIndex = size - 1;
    }

public:
    CircularDeque(int initialSize = 0)
        : capacity(initialSize > 0 ? initialSize : 1),
          size(0), frontIndex(0), rearIndex(-1) {
        buffer = new T[capacity];
    }

    ~CircularDeque() {
        delete[] buffer;
    }

    bool isEmpty() const {
        return size == 0;
    }

    int getSize() const {
        return size;
    }

    void push_back(const T& value) {
        if (size == capacity) resize();
        rearIndex = (rearIndex + 1) % capacity;
        buffer[rearIndex] = value;
        ++size;
    }

    void push_front(const T& value) {
        if (size == capacity) resize();
        frontIndex = (frontIndex - 1 + capacity) % capacity;
        buffer[frontIndex] = value;
        ++size;
    }

    T pop_front() {
        if (isEmpty()) throw std::out_of_range("empty");
        T value = buffer[frontIndex];
        frontIndex = (frontIndex + 1) % capacity;
        --size;
        return value;
    }

    T pop_back() {
        if (isEmpty()) throw std::out_of_range("empty");
        T value = buffer[rearIndex];
        rearIndex = (rearIndex - 1 + capacity) % capacity;
        --size;
        return value;
    }

    T& front() {
        if (isEmpty()) throw std::out_of_range("empty");
        return buffer[frontIndex];
    }

    const T& front() const {
        if (isEmpty()) throw std::out_of_range(" empty");
        return buffer[frontIndex];
    }

    T& back() {
        if (isEmpty()) throw std::out_of_range("empty");
        return buffer[rearIndex];
    }

    const T& back() const {
        if (isEmpty()) throw std::out_of_range("empty");
        return buffer[rearIndex];
    }

    T& operator[](int index) {
        if (index < 0 || index >= size) throw std::out_of_range("Index out of range");
        return buffer[(frontIndex + index) % capacity];
    }

    const T& operator[](int index) const {
        if (index < 0 || index >= size) throw std::out_of_range("Index out of range");
        return buffer[(frontIndex + index) % capacity];
    }
};

int main() {
    CircularDeque<int> dq;
    dq.push_back(10);
    dq.push_back(20);
    dq.push_front(5);
    std::cout << "Front: " << dq.front() << '\n';
    std::cout << "Back: " << dq.back() << '\n';
    dq.pop_front();
    dq.push_back(30);
    std::cout << "Elements: ";
    for (int i = 0; i < dq.getSize(); ++i)
        std::cout << dq[i] << " ";
    std::cout << '\n';
    return 0;
}
